

\begin{code}
-- {-# OPTIONS --rewriting #-}
module SynthHom where

open import Agda.Primitive renaming (Set to ğ“¤)

variable
    â„“ ğ“‡ ğ“ˆ : Level

data ğŸ˜ : ğ“¤ where

record ğŸ™ : ğ“¤ where

record Î£ {â„“ ğ“‡} (A : ğ“¤ â„“) (B : A â†’ ğ“¤ ğ“‡) : ğ“¤ (â„“ âŠ” ğ“‡) where
    constructor _,_
    field
        fst : A
        snd : B fst

open Î£

data â„• : ğ“¤ where
    zero : â„•
    suc : â„• â†’ â„•

{-# BUILTIN NATURAL â„• #-}

âŸ¨_,_âŸ© : âˆ€ {A : ğ“¤ â„“} {B : A â†’ ğ“¤ ğ“‡} {X : ğ“¤ ğ“ˆ} â†’ (f : X â†’ A) â†’ ((x : X) â†’ B (f x)) â†’ (X â†’ Î£ A B)   
âŸ¨ f , g âŸ© a = (f a , g a)
    
Î£-univ : âˆ€ {A : ğ“¤ â„“} {B : A â†’ ğ“¤ ğ“‡} {X : ğ“¤ ğ“‡} â†’ (Î£ (X â†’ A) Î» f â†’ ((x : X) â†’ B (f x))) â†’ (X â†’ Î£ A B)
Î£-univ sum = âŸ¨ fst sum , snd sum âŸ©

data  _ï¼_ {A : ğ“¤ â„“} (a : A) : A â†’ ğ“¤ â„“ where
    refl : a ï¼ a

J : âˆ€ {A : ğ“¤ â„“} {x : A} (P : (a : A) â†’ x ï¼ a â†’ ğ“¤ ğ“‡) â†’ P x refl â†’ (y : A) (p : x ï¼ y) â†’ P y p
J P x y refl = x

ap : {A : ğ“¤ â„“} â†’ {B : ğ“¤ ğ“‡} {x y : A} â†’ (f : A â†’ B) â†’ x ï¼ y â†’ f x ï¼ f y
ap {x = x} {y} f p = J (Î» a _ â†’ f x ï¼ f a) refl y p

_âˆ™_ : âˆ€ {A : ğ“¤ â„“} â†’ {a b c : A} â†’ a ï¼ b â†’ b ï¼ c â†’ a ï¼ c
refl âˆ™ p = p

_â»Â¹ : âˆ€ {A : ğ“¤ â„“} â†’ {a b : A} â†’ a ï¼ b â†’ b ï¼ a
refl â»Â¹ = refl

-- {-# BUILTIN REWRITE _ï¼_ #-}

fibre : âˆ€ {X : ğ“¤ â„“} {Y : ğ“¤ ğ“‡} â†’ (X â†’ Y) â†’ Y â†’ ğ“¤ (â„“ âŠ” ğ“‡)
fibre {X = X} f y = Î£ X Î» x â†’ f x ï¼ y   

is-contr : ğ“¤ â„“ â†’ ğ“¤ â„“
is-contr A = Î£ A Î» a â†’ (b : A) â†’ a ï¼ b  

is-[_]-type : â„• â†’ ğ“¤ â„“ â†’ ğ“¤ â„“
is-[ zero ]-type X = is-contr X
is-[ suc n ]-type X = âˆ€ {x y : X} â†’ is-[ n ]-type (x ï¼ y)

is-prop is-set : ğ“¤ â„“ â†’ ğ“¤ â„“
is-prop = is-[ 1 ]-type
is-set = is-[ 2 ]-type

ğ“¤< : â„• â†’ (â„“ : Level) â†’ ğ“¤ (lsuc â„“)
ğ“¤< n â„“ = Î£ (ğ“¤ â„“) is-[ n ]-type

record Underlying (A : ğ“¤ â„“) (U : ğ“¤ ğ“‡) : ğ“¤ (â„“ âŠ” ğ“‡) where
    field âŒ_âŒŸ : A â†’ U

open Underlying {{...}}

instance
    UnderlyingÎ£ : âˆ€ {A : ğ“¤ â„“} {B : A â†’ ğ“¤ ğ“‡} â†’ Underlying (Î£ A B) A
    Underlying.âŒ UnderlyingÎ£ âŒŸ = fst

is-equiv : âˆ€ {X : ğ“¤ â„“} {Y : ğ“¤ ğ“‡} â†’ (f : X â†’ Y) â†’ ğ“¤ (â„“ âŠ” ğ“‡)
is-equiv {Y = Y} f = (y : Y) â†’ is-contr (fibre f y) 

is-equivâ†’inverse : âˆ€ {X : ğ“¤ â„“} {Y : ğ“¤ ğ“‡} â†’ (f : X â†’ Y) â†’ is-equiv f â†’ Y â†’ X
is-equivâ†’inverse f e y = fst (fst (e y))

Equiv : ğ“¤ â„“ â†’ ğ“¤ ğ“‡ â†’ ğ“¤ (â„“ âŠ” ğ“‡)
Equiv A B = Î£ (A â†’ B) is-equiv

id : {A : ğ“¤ â„“} â†’ A â†’ A
id x = x

_âˆ˜_ : {A : ğ“¤ â„“} {B : ğ“¤ ğ“‡} {C : ğ“¤ ğ“ˆ} â†’ (B â†’ C) â†’ (A â†’ B) â†’ A â†’ C
(f âˆ˜ g) x = f (g x)



idEquiv : âˆ€ {A : ğ“¤ â„“} â†’ Equiv A A
idEquiv = id , Î» y â†’ (y , refl) , (Î» where (a , refl) â†’ refl)

idToEquiv : âˆ€ {X Y : ğ“¤ â„“} â†’ X ï¼ Y â†’ Equiv X Y
idToEquiv refl = idEquiv 

record Identity (A : ğ“¤ â„“) (i : Level) : ğ“¤ (â„“ âŠ” lsuc i) where
    field Id       : A â†’ A â†’ ğ“¤ i
    field Ï‡ : âˆ€ {x y : A} â†’ x ï¼ y â†’ Id x y
    field Ï‡-equiv : âˆ€ {x y : A} â†’ is-equiv (Ï‡ {x} {y})

    toPath : âˆ€ {x y : A} â†’ Id x y â†’ x ï¼ y
    toPath = is-equivâ†’inverse Ï‡ Ï‡-equiv 
 
open Identity {{...}}

postulate
    ua : âˆ€ {X Y : ğ“¤ â„“} â†’ is-equiv (idToEquiv {X = X} {Y})

-- instance
--     trivId : {A : ğ“¤ â„“} â†’ Identity A â„“
--     Identity.Id trivId = _ï¼_
--     Identity.Ï‡ trivId = id
--     Identity.Ï‡-equiv trivId = idEquiv .snd

-- {-# OVERLAPPABLE trivId #-}

instance
    pathId : Identity (ğ“¤ â„“) â„“
    Identity.Id pathId = Equiv
    Identity.Ï‡ pathId = idToEquiv
    Identity.Ï‡-equiv pathId = ua

_*[_]_ : {A : ğ“¤ â„“} â†’ {x y : A} â†’ x ï¼ y â†’ (B : A â†’  ğ“¤ ğ“‡) â†’ (x' : B x) â†’ B y
p *[ B ] x' = J (Î» a _ â†’ B a) x' _ p

_*[_] : {A : ğ“¤ â„“} â†’ {x y : A} â†’ x ï¼ y â†’ (B : A â†’  ğ“¤ ğ“‡) â†’ B x ï¼ B y
refl *[ B ] = refl

*[]-is-equiv : {A : ğ“¤ â„“} â†’ {x y : A} â†’ (p : x ï¼ y) â†’ (B : A â†’  ğ“¤ ğ“‡) â†’ is-equiv (p *[ B ]_)
fst (*[]-is-equiv refl B y) = y , refl
snd (*[]-is-equiv refl B y) (.y , refl) = refl

equivToId : âˆ€  {X Y : ğ“¤ â„“} â†’ Equiv X Y â†’ X ï¼ Y
equivToId = toPath

Î£-id : âˆ€ {A : ğ“¤ â„“} {B : A â†’ ğ“¤ ğ“‡} â†’ Î£ A B â†’ Î£ A B â†’ ğ“¤ (â„“ âŠ” ğ“‡)
Î£-id {B = B} x y = Î£ (fst x ï¼ fst y) Î» p â†’ (p *[ B ] (snd x)) ï¼ snd y

Î£-id-Ï‡ : âˆ€ {A : ğ“¤ â„“} {B : A â†’ ğ“¤ ğ“‡} â†’ (x y : Î£ A B) â†’ x ï¼ y â†’ Î£-id x y
Î£-id-Ï‡ x .x refl = refl , refl

Î£-id-Ï‡-equiv : âˆ€ {A : ğ“¤ â„“} {B : A â†’ ğ“¤ ğ“‡} {x y : Î£ A B} â†’ is-equiv (Î£-id-Ï‡ x y)
Î£-id-Ï‡-equiv {x = x1 , x2} {y = y1 , y2} (refl , refl) = (refl , refl) , Î» where (refl , refl) â†’ refl


instance
    Î£-Id : âˆ€ {A : ğ“¤ â„“} {B : A â†’ ğ“¤ ğ“‡} â†’ Identity (Î£ A B) (â„“ âŠ” ğ“‡)
    Identity.Id Î£-Id = Î£-id
    Identity.Ï‡ Î£-Id = Î£-id-Ï‡ _ _
    Identity.Ï‡-equiv Î£-Id = Î£-id-Ï‡-equiv

postulate
    inverse-equiv : âˆ€ {A : ğ“¤ â„“} {B : ğ“¤ ğ“‡} â†’ (f : A â†’ B) â†’ (e : is-equiv f) â†’ is-equiv (is-equivâ†’inverse f e)
-- fst (inverse-equiv f e x) = f x , ap fst (snd (e (f x)) (x , refl))
-- snd (inverse-equiv f e x) b = toPath ({!   !} , {!   !})

Equivâ»Â¹ : âˆ€ {A : ğ“¤ â„“} {B : ğ“¤ ğ“‡} â†’ Equiv A B â†’ Equiv B A
Equivâ»Â¹ (f , f-eq) = (is-equivâ†’inverse f f-eq , inverse-equiv f f-eq)
    
postulate funext : âˆ€ {A : ğ“¤ â„“} {B : A â†’ ğ“¤ ğ“‡} {f g : (a : A) â†’ B a} â†’ (âˆ€ x â†’ f x ï¼ g x) â†’ f ï¼ g -- TODO
-- funext {f = f} {g} p = {!    !}

instance
    Î -Id : âˆ€ {A : ğ“¤ â„“} {B : A â†’ ğ“¤ ğ“‡} â†’ Identity ((x : A) â†’ B x) (â„“ âŠ” ğ“‡)
    Identity.Id Î -Id f g = âˆ€ x â†’ f x ï¼ g x
    Identity.Ï‡ Î -Id refl x = refl
    Identity.Ï‡-equiv Î -Id {f} {g} y = (funext y , cheat) , cheat  where
        postulate cheat : âˆ€ {A : ğ“¤ â„“} â†’ A -- TODO!!



\end{code}  

\section{Truncation}

\begin{code}

postulate
    âˆ¥_âˆ¥[_] : ğ“¤ â„“ â†’ â„• â†’ ğ“¤ â„“
    âˆ£_âˆ£[_] : {A : ğ“¤ â„“} â†’ A â†’ (n : â„•) â†’ âˆ¥ A âˆ¥[ n ]
    âˆ¥_âˆ¥[_]-out : (A : ğ“¤ â„“) â†’ (n : â„•) â†’ {B : ğ“¤< n ğ“‡} â†’ (A â†’ âŒ B âŒŸ) â†’ (âˆ¥ A âˆ¥[ n ] â†’ âŒ B âŒŸ)
    âˆ¥_âˆ¥[_]-out-equiv : (A : ğ“¤ â„“) â†’ (n : â„•) â†’ {B : ğ“¤< n ğ“‡} â†’ is-equiv (âˆ¥ A âˆ¥[ n ]-out {B})

âˆ¥_âˆ¥ : ğ“¤ â„“ â†’ ğ“¤ â„“
âˆ¥ A âˆ¥ = âˆ¥ A âˆ¥[ 1 ]

âˆ£-âˆ£-comm : âˆ€ {n} {A : ğ“¤ â„“} {B : ğ“¤< n ğ“‡} â†’ (f : A â†’ âŒ B âŒŸ) â†’ f ï¼ (âˆ¥ A âˆ¥[ n ]-out {B} f âˆ˜ âˆ£_âˆ£[ n ])
âˆ£-âˆ£-comm f = toPath (Î» x â†’ {!   !})

is-[_]-connected : â„• â†’ ğ“¤ â„“ â†’ ğ“¤ â„“
is-[ n ]-connected A = is-contr âˆ¥ A âˆ¥[ n ]

-- record co-universal (A : ğ“¤ â„“) (B : ğ“¤ ğ“‡) {{_ : Underlying B (ğ“¤ ğ“ˆ)}} : ğ“¤ (lsuc â„“ âŠ” ğ“‡ âŠ” ğ“ˆ) where
--     field Rep  : ğ“¤ â„“
--     field Î¹   : Rep â†’ A
--     field elim : âˆ€ {b : B} â†’ (Rep â†’ âŒ b âŒŸ) â†’ (A â†’ âŒ b âŒŸ)
--     field elim-equiv : âˆ€ {b : B} â†’ is-equiv (elim {b})

--     commutes : âˆ€ {b : B} â†’ (f : Rep â†’ âŒ B âŒŸ) â†’ f ï¼ Î¹

-- open co-universal {{...}}

-- instance
--     âˆ¥-âˆ¥-univ : âˆ€ {A : ğ“¤ â„“} {n : â„•} â†’ co-universal âˆ¥ A âˆ¥[ n ] (ğ“¤< n ğ“‡)
--     co-universal.Rep (âˆ¥-âˆ¥-univ {A = A}) = A
--     co-universal.Î¹ âˆ¥-âˆ¥-univ = âˆ£_âˆ£[ _ ]
--     co-universal.elim âˆ¥-âˆ¥-univ {b} = âˆ¥ _ âˆ¥[ _ ]-out {b}
--     co-universal.elim-equiv âˆ¥-âˆ¥-univ = âˆ¥ _ âˆ¥[ _ ]-out-equiv

 
  
\end{code} 